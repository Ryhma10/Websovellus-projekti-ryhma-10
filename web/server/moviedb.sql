-- Citex on case-insensitiivinen tekstityyppi (yksinkertaistaa UNIQUE:a)
CREATE EXTENSION IF NOT EXISTS citext;

-- Enumit
DO $$ BEGIN
  CREATE TYPE membership_role   AS ENUM ('owner', 'member');
EXCEPTION WHEN duplicate_object THEN NULL; END $$;
 
DO $$ BEGIN
  CREATE TYPE membership_status AS ENUM ('pending', 'approved', 'rejected');
EXCEPTION WHEN duplicate_object THEN NULL; END $$;
 
-- Taulu users
CREATE TABLE IF NOT EXISTS users (
  id            int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  username      citext      NOT NULL,
  email         citext      NOT NULL,
  password_hash text        NOT NULL,
  profile_picture_url text,
  -- Varmistetaan uniikit arvot kirjainkoosta riippumatta (citext hoitaa tässä), 
  -- saadaan APIssa ilmaistua 409 joko email tai username taken<<<
  CONSTRAINT users_username_uq UNIQUE (username),
  CONSTRAINT users_email_uq    UNIQUE (email)
);

-- Tehdään trigger, joka varmistaa, että vain käyttäjä itse saa poistaa tilinsä
CREATE OR REPLACE FUNCTION users_delete_guard()
RETURNS trigger
LANGUAGE plpgsql
AS $$
DECLARE
  acting_user_id int;
BEGIN
  -- Tehdään acting_user_id, johon tallentuu nykyisen transaktion käyttäjä-ID, jos tyhjä = NULL
  acting_user_id := NULLIF(current_setting('app.user_id', true), '')::int;
  IF acting_user_id IS NULL THEN
    RAISE EXCEPTION 'Permission denied: app.user_id not set';
  END IF;

  IF acting_user_id = OLD.id THEN
    RETURN OLD;  -- annetaan lupa poistaa rivi, (RETURN NULL=ei poisteta, RAISE EXCEPTION=komento keskeytyy virheeseen)
  END IF;

  RAISE EXCEPTION 'Only the user can delete their own account';
END;
$$;

DROP TRIGGER IF EXISTS trg_users_delete_guard ON users;

CREATE TRIGGER trg_users_delete_guard
BEFORE DELETE ON users
FOR EACH ROW
EXECUTE FUNCTION users_delete_guard();

-- Taulu reviews
CREATE TABLE IF NOT EXISTS reviews (
  id         int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id    int NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  tmdb_id    int NOT NULL,
  stars      int NOT NULL,
  body       text NOT NULL,
  created_at timestamptz NOT NULL DEFAULT now(),
  CONSTRAINT chk_reviews_stars CHECK (stars BETWEEN 1 AND 5)
);
CREATE UNIQUE INDEX IF NOT EXISTS uq_reviews_user_tmdb ON reviews (user_id, tmdb_id);
CREATE INDEX IF NOT EXISTS idx_reviews_user ON reviews (user_id);
CREATE INDEX IF NOT EXISTS idx_reviews_tmdb ON reviews (tmdb_id);

-- Käyttäjien suosikkielokuvien taulu
CREATE TABLE user_favorites (
    user_id INT NOT NULL, -- Viittaa käyttäjään (users-taulun id)
    tmdb_id INT NOT NULL, -- Elokuvan TMDB-tietokannan id
    position INT, -- Suosikin järjestys (valinnainen)
    added_at TIMESTAMPTZ NOT NULL DEFAULT NOW(), -- Aikaleima
    PRIMARY KEY (user_id, tmdb_id), -- Yhdistelmäavain: yksi elokuva voi olla vain kerran
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE-- Jos käyttäjä poistetaan, suosikkilista poistuu
);

-- Ryhmille oma taulu
CREATE TABLE IF NOT EXISTS groups (
  id       int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name     text NOT NULL,
  owner_id int  NOT NULL REFERENCES users(id) ON DELETE CASCADE
);
CREATE INDEX IF NOT EXISTS idx_groups_owner ON groups (owner_id);

-- Ryhmien jäsenien taulu
CREATE TABLE IF NOT EXISTS group_memberships (
  group_id int NOT NULL REFERENCES groups(id) ON DELETE CASCADE,
  user_id  int NOT NULL REFERENCES users(id)  ON DELETE CASCADE,
  status   membership_status NOT NULL DEFAULT 'pending',
  role     membership_role,
  CONSTRAINT pk_group_memberships PRIMARY KEY (group_id, user_id),
  CONSTRAINT chk_group_memberships_role
    CHECK (
      (status <> 'approved' AND role IS NULL)
      OR
      (status = 'approved'  AND role IS NOT NULL)
    )
);
CREATE INDEX IF NOT EXISTS idx_group_memberships_user   ON group_memberships (user_id);
CREATE INDEX IF NOT EXISTS idx_group_memberships_status ON group_memberships (group_id, status);
-- vain yksi owner / ryhmä (vain approved)
CREATE UNIQUE INDEX IF NOT EXISTS uq_group_memberships_owner
  ON group_memberships (group_id)
  WHERE status = 'approved' AND role = 'owner';
 
-- group_movies: useita leffoja / user / group, ei tuplia samasta tunnisteesta
CREATE TABLE IF NOT EXISTS group_movies (
  id          int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  group_id    int NOT NULL REFERENCES groups(id) ON DELETE CASCADE,
  user_id     int NOT NULL REFERENCES users(id)  ON DELETE CASCADE,

  -- Täsmälleen yksi lähde: TMDB TAI Finnkino
  tmdb_id     int,
  finnkino_id int,

  note        text,
  stars       int,
  created_at  timestamptz NOT NULL DEFAULT now(),

  -- snapshot-kentät kortin renderöintiä varten
  snap_title       text,
  snap_overview    text,
  snap_poster_url  text,

  -- Finnkino-näytösajat JSONB:nä (teatteri + ajat)
  -- Muoto: [
  --   { "theatreId":"1029","theatreName":"Tennispalatsi","city":"Helsinki",
  --     "showtimes":[{"startsAt":"2025-10-08T18:30:00+03:00","auditorium":"Sali 3"}]
  --   },
  --   ...
  -- ]
  finnkino_showtimes jsonb,

  CONSTRAINT chk_group_movies_ids   CHECK (tmdb_id IS NOT NULL OR finnkino_id IS NOT NULL),
  CONSTRAINT chk_group_movies_one_source CHECK (
    (tmdb_id IS NOT NULL AND finnkino_id IS NULL) OR
    (tmdb_id IS NULL AND finnkino_id IS NOT NULL)
  ),
  CONSTRAINT chk_group_movies_stars CHECK (stars IS NULL OR stars BETWEEN 1 AND 5),

  -- JSON-tyyppivarmistus
  CONSTRAINT chk_gm_finnkino_showtimes_json
    CHECK (finnkino_showtimes IS NULL OR jsonb_typeof(finnkino_showtimes) = 'array'),

  -- Nimetyt UNIQUE-rajoitteet -> suora tuki ON CONFLICTille
  CONSTRAINT uq_gm_tmdb UNIQUE (group_id, user_id, tmdb_id),
  CONSTRAINT uq_gm_finn UNIQUE (group_id, user_id, finnkino_id)
);

-- Hyödylliset apuindeksit listauksille
CREATE INDEX IF NOT EXISTS idx_group_movies_group          ON group_movies (group_id);
CREATE INDEX IF NOT EXISTS idx_group_movies_user           ON group_movies (user_id);
CREATE INDEX IF NOT EXISTS idx_group_movies_group_created  ON group_movies (group_id, created_at DESC);
